# OyunProje1
2D Platform Oyun Projesi

Godot oyun geliştirme motorunun yazılım dili olan GDScript i kullandım. Önce GameManager adında bir kod dizimi oluşturdum. Bu kodda oyuncunun canı, toplanan elmas ve kiraz miktarlarını tutuyor onları diğer kodlara yönlendiriyorum. Ardından oyuncunun kodunu oluşturdum ve fizik, oyuncunun kontrolü, animasyonlar, ölüm gibi mekanikleri kodladım. Bu kodlardan bazılarına örnek:
Godot oyun geliştirme motorunun yazılım dili olan GDScript i kullandım. Bu kodlardan bazılarına örnek:

bat.gd – Yarasa Düşmanı
• _physics_process(): Yarasa sürekli ileri uçar, sinüsle yukarı-aşağı süzülür.
• _on_timer_timeout(): Süre dolunca yön değiştirir (x yönü ters çevrilir).
• _on_area_2d_body_entered(body): Üstten vurulursa ölür, yoksa oyuncuya zarar verir (knockback).
• die(): Ölüm animasyonu başlatır ve yok eder.

cherry.gd – Kiraz (Toplanabilir)
• _on_area_entered(body): Oyuncuya çarpınca animasyon oynar, kiraz sayısını GameManagerda değeri artırır ve kendini yok eder.

control.gd – Can UI

• update_lives(lives): Mevcut cana göre kalp ikonlarını dolu/boş yapar.

door.gd – Kapı
• _ready(): GameManager'dan ID’yi kontrol eder, açıksa animasyonla kapıyı açar (CollisionShape kapatılır).
• open(): Animasyonu oynatır ve engelleri devre dışı bırakır.

eagle.gd – Kartal Düşman
• _physics_process(): Kartal dikey hareket eder (sinüsle).
• _on_timer_timeout(): Süre dolunca yön değiştirir.
• _on_area_2d_body_entered(body): Üstten vurulursa ölür, yoksa oyuncuya zarar verir (knockback).
• die(): Üstten vurulursa ölür, yoksa oyuncuya zarar verir (knockback).

ending.gd – Bitiş Ekranı
• _ready(): GameManager’dan alınan istatistikleri yazıya döker.
• calculate_rank(): Toplanan taş ve kiraza göre puan hesaplar, harf notu verir.

feedback.gd – Toplama Efekti
• show_feedback(text, pos): Belirli pozisyonda yazıyı gösterip kısa animasyonla kaybolur.

frog.gd – Kurbağa Düşman
• _ready(): Zıplama zamanlayıcısını başlatır.
• _on_timer_timeout(): Süre dolunca kurbağa sıçrar ve yön değiştirir.
• _on_area_2d_body_entered(body): Üstten vurulursa ölür, yoksa oyuncuya zarar verir (knockback).

fullscreencontrol.gd – Tam Ekran Ayarı
• _on_check_button_toggled(button_pressed): Buton açıksa tam ekran yapar, değilse pencere moduna döner.

GameManager.gd – Oyun Yöneticisi 
• Değişkenler: Can, taş, kiraz sayısı, açılan kapılar.
• take_damage(): Can azaltır, sıfırsa oyuncuyu öldürür.
• add_gem/cherry(): Sayıları artırır ve sinyal yollar.
• open_door(id): Kapı ID'sini açık listeye ekler.
• Sinyaller: UI ve diğer sistemlere haber verir.

gem.gd – Taş (Toplanabilir)
• _on_area_entered(body): Oyuncuya temasla GameManager'a taş ekletir, efekt oynatır, yok olur.

invincibilitycontrol.gd – Yenilmezlik
• _on_check_button_toggled(): Açıldığında canı 999 yapar, kapandığında 3'e döner.

key.gd – Anahtar
• _on_area_entered(body): GameManager’da ilgili kapıyı açar, anahtar kaybolur.

main_menu.gd – Ana Menü
• on_play_button_pressed(): Oyunu başlatır.
• on_settings_button_pressed(): Ayarları açar.
• on_quit_button_pressed(): Oyunu kapatır.

slider.gd – Ses Kontrolü
• on_value_changed(value): Seçilen ses kategorisinin ses seviyesini değiştirir.

opossum.gd – Opossum Düşman
• _physics_process(): Yatay yürür, yönünü sprite ile birlikte değiştirir.
• on_timer_timeout(): Süre dolunca yön değiştirir.
• _on_area_2d_body_entered(body): Üstten vurulursa ölür, değilse oyuncuya zarar verir.

player.gd – Oyuncu
• Hareket, zıplama, tırmanma ve animasyon kontrolü.
• take_damage(): Can azaltır, invincibility varsa hasar yemez.
• knockback(): Geri savrulma efekti.
• die(): Ölüm animasyonu, ardından sahneyi yeniden yükler.

ui.gd – Oyun UI
• Sinyallerle taş ve kiraz sayılarını alır ve Label'ları günceller.



Kodlar:
Bat.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends CharacterBody2D const SPEED = 40.0 const FLOAT_AMPLITUDE = 20.0 const FLOAT_SPEED = 2.0 var direction := 1 var is_dead := false var base_y_position: float var time := 0.0 func _ready(): 	base_y_position = global_position.y func _physics_process(delta): 	if is_dead: 		return 	time += delta 	velocity.x = direction * SPEED 	velocity.y = sin(time * FLOAT_SPEED) * FLOAT_AMPLITUDE 	move_and_slide() 	$AnimatedSprite2D.flip_h = direction < 0 func die(): 	if is_dead: 		return 	is_dead = true 	 	$AnimatedSprite2D.play("death") 	if not $AnimatedSprite2D.animation_finished.is_connected(_on_death_animation_finished): 		$AnimatedSprite2D.animation_finished.connect(_on_death_animation_finished) 	set_physics_process(false) 	$CollisionShape2D.call_deferred("set_disabled", true) func _on_death_animation_finished(): 	queue_free() func _on_timer_timeout() -> void: 	if is_dead: 		return 	direction *= -1 func _on_area_2d_2_body_entered(body: Node2D) -> void: 	if is_dead: 		return 	if body.is_in_group("Player"): 		var vertical_diff = body.global_position.y - global_position.y 		if vertical_diff < -10: 			if "velocity" in body: 				body.velocity.y = -250 			die() 		else: 			 			if body.has_method("apply_knockback"): 				var knockback_direction = (body.global_position - global_position).normalized() 				body.apply_knockback(knockback_direction, 150.0, 0.16, true) 			print("Oyuncu canı: ", GameManager.player_lives) func _on_area_2d_body_entered(body: Node2D) -> void: 	if is_dead: 		return 	if body.is_in_group("Player"): 		if "velocity" in body: 			body.velocity.y = -250 		die() ------------------------------------------------------------------------------------------------------------------------------------------ cherry.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends Area2D @onready var animation_player: AnimationPlayer = $AnimationPlayer func _on_body_entered(body: Node2D) -> void: 	GameManager.gain_cherry(1) 	GameManager.show_item_feedback("feedback", global_position) 	animation_player.play("pickup") ------------------------------------------------------------------------------------------------------------------------------------------ control.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends Control func update_hearts(lives: int) -> void: 	for i in range(3): 		var heart = $HBoxContainer.get_child(i) 		heart.texture = preload("res://Assets/Props Items and VFX/Sunnyland items/heart_empty.png") 	 	for i in range(lives): 		var heart = $HBoxContainer.get_child(i) 		heart.texture = preload("res://Assets/Props Items and VFX/Sunnyland items/heart_full.png") ------------------------------------------------------------------------------------------------------------------------------------------ door.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends StaticBody2D @export var door_id: String = "B" @export var is_open: bool = false func _ready(): 	_check_if_should_open() func _process(delta): 	if not is_open and GameManager.opened_doors.has(door_id): 		open() func _check_if_should_open(): 	if GameManager.opened_doors.has(door_id): 		open() func open(): 	if not is_open: 		is_open = true 		$AnimatedSprite2D.play("open") 		$CollisionShape2D.set_deferred("disabled", true) ------------------------------------------------------------------------------------------------------------------------------------------ eagle.gd ------------------------------------------------------------------------------------------------------------------------------------------ 	extends CharacterBody2D 	const SPEED = 40.0 	var direction := 1 	var is_dead := false 	var time := 0.0 	func _ready(): 		pass 	func _physics_process(delta): 		if is_dead: 			return 		# Dikey hareket 		velocity.y = direction * SPEED 		velocity.x = 0 		move_and_slide() 	func die(): 		if is_dead: 			return 		is_dead = true 		 		$AnimatedSprite2D.play("death") 		if not $AnimatedSprite2D.animation_finished.is_connected(_on_death_animation_finished): 			$AnimatedSprite2D.animation_finished.connect(_on_death_animation_finished) 		set_physics_process(false) 		$CollisionShape2D.call_deferred("set_disabled", true) 	func _on_death_animation_finished(): 		queue_free() 	func _on_timer_timeout() -> void: 		if is_dead: 			return 		direction *= -1 	func _on_area_2d_2_body_entered(body: Node2D) -> void: 		if is_dead: 			return 		if body.is_in_group("Player"): 			var vertical_diff = body.global_position.y - global_position.y 			if vertical_diff < -10: 				if "velocity" in body: 					body.velocity.y = -250 				die() 			else: 				 				if body.has_method("apply_knockback"): 					var knockback_direction = (body.global_position - global_position).normalized() 					body.apply_knockback(knockback_direction, 150.0, 0.16, true) 				print("Oyuncu canı: ", GameManager.player_lives) 	func _on_area_2d_body_entered(body: Node2D) -> void: 		if is_dead: 			return 		if body.is_in_group("Player"): 			if "velocity" in body: 				body.velocity.y = -250 			die() 		 ------------------------------------------------------------------------------------------------------------------------------------------ ending.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends Control @onready var label = $VBoxContainer/Label @onready var label2 = $VBoxContainer/Label2 @onready var rank_label = $VBoxContainer/RankLabel @onready var button = $Button func _ready(): 	var gems = GameManager.gems 	var cherry = GameManager.cherry 	var lives = GameManager.player_lives 	var rank = calculate_rank(gems, cherry) 	rank_label.text = "RANK: %s" % rank 	rank_label.label_settings = get_rank_style(rank) 	label.text = "Congrats, you finished the game!" 	label2.text = "Collected Gems: %d / 40\nCollected Cherry: %d / 8\nRemaining Lives: %d"% [ 		gems, 		cherry, 		lives, 	] 	button.text = "Back To Main Menu" 	button.pressed.connect(_on_button_pressed) func calculate_rank(gems: int, cherry: int) -> String: 	var gem_percentage = float(gems) / 40.0 	var cherry_percentage = float(cherry) / 8.0 	if gem_percentage >= 1.0 and cherry_percentage >= 1.0: 		return "S" 	elif gem_percentage >= 0.8 and cherry_percentage >= 0.75: 		return "A" 	elif gem_percentage >= 0.5 and cherry_percentage >= 0.5: 		return "B" 	else: 		return "C" func get_rank_style(rank: String) -> LabelSettings: 	var style = LabelSettings.new() 	style.font_size = 64 	var font = load("res://Assets/Grades.ttf") 	style.font = font 	match rank: 		"S": 			style.font_color = Color8(255, 215, 0) 		"A": 			style.font_color = Color.GREEN 		"B": 			style.font_color = Color.ORANGE 		"C": 			style.font_color = Color.RED 	return style func _on_button_pressed(): 	GameManager.reset_game_data() 	get_tree().change_scene_to_file("res://Scenes/main_menu.tscn") ------------------------------------------------------------------------------------------------------------------------------------------ feedback.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends Node2D func play_animation(anim_name: String): 	var anim = $AnimatedSprite2D 	anim.play(anim_name) 	anim.animation_finished.connect(queue_free) ------------------------------------------------------------------------------------------------------------------------------------------ frog.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends CharacterBody2D const SPEED = 80.0 const JUMP_VELOCITY = -400.0 var direction := 1 var gravity = ProjectSettings.get_setting("physics/2d/default_gravity") var is_dead := false func _physics_process(delta): 	if is_dead: 		return 	if is_on_floor(): 		velocity.x = 0 		$AnimatedSprite2D.play("idle") 	else: 		velocity.x = direction * SPEED 		velocity.y += gravity * delta 		if velocity.y > 0: 			$AnimatedSprite2D.play("jump") 	move_and_slide() 	$AnimatedSprite2D.flip_h = direction > 0 func jump(): 	velocity.y = JUMP_VELOCITY func die(): 	if is_dead: 		return 	is_dead = true 	$AnimatedSprite2D.play("death") 	if not $AnimatedSprite2D.animation_finished.is_connected(_on_death_animation_finished): 		$AnimatedSprite2D.animation_finished.connect(_on_death_animation_finished) 	set_physics_process(false) 	$CollisionShape2D.call_deferred("set_disabled", true) 	$Area2D.monitoring = false 	$Area2D2.monitoring = false func _on_death_animation_finished(): 	queue_free() func _on_timer_timeout(): 	if is_dead: 		return 	direction *= -1 	jump() func _on_area_2d_2_body_entered(body: Node2D) -> void: 	if is_dead: 		return 	if body.is_in_group("Player"): 		var vertical_diff = body.global_position.y - global_position.y 		if vertical_diff < -10: 			if "velocity" in body: 				body.velocity.y = -250 			die() 		else: 			if body.has_method("apply_knockback"): 				var knockback_direction = (body.global_position - global_position).normalized() 				body.apply_knockback(knockback_direction, 150.0, 0.16, true) 			print("Oyuncu canı: ", GameManager.player_lives) func _on_area_2d_body_entered(body: Node2D) -> void: 	if is_dead: 		return 	if body.is_in_group("Player"): 		if "velocity" in body: 			body.velocity.y = -250 		die() ------------------------------------------------------------------------------------------------------------------------------------------ fullscreencontrol.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends CheckButton func _on_toggled(toggled_on: bool) -> void: 	if toggled_on == false: 		DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_WINDOWED) 	else: 		DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_FULLSCREEN) ------------------------------------------------------------------------------------------------------------------------------------------ Gamemanager.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends Node signal gained_gems(int) signal gained_cherry(int) var player_lives := 3 var gems : int = 0 var cherry : int = 0 var invincibility := false var opened_doors: Array = [] func reset(): 	opened_doors.clear() func reset_game_data(): 	player_lives = 3 	gems = 0 	cherry = 0 	opened_doors.clear() func gain_gems(gems_gained: int): 	gems += gems_gained 	emit_signal("gained_gems", gems_gained) 	print("Gems: ", gems) func gain_cherry(cherry_gained: int): 	cherry += cherry_gained 	emit_signal("gained_cherry", cherry_gained) 	print("Cherry: ", cherry) var FeedbackEffectScene = preload("res://Scenes/item_feedback.tscn") func show_item_feedback(anim_name: String, pos: Vector2) -> void: 	var feedback = FeedbackEffectScene.instantiate() 	feedback.position = pos 	feedback.play_animation(anim_name) 	get_tree().current_scene.add_child(feedback) ------------------------------------------------------------------------------------------------------------------------------------------ gem.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends Area2D @onready var animation_player: AnimationPlayer = $Pickup/AnimationPlayer func _on_body_entered(body: Node2D) -> void: 	GameManager.gain_gems(1) 	GameManager.show_item_feedback("feedback", global_position) 	animation_player.play("pickup") ------------------------------------------------------------------------------------------------------------------------------------------ invincibilitycontrol.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends CheckButton func _on_toggled(toggled_on: bool) -> void: 	GameManager.invincibility = toggled_on 	if toggled_on: 		GameManager.player_lives = 999 		print("Invicibility is open ! Can: ", GameManager.player_lives) 	else: 		GameManager.player_lives = 3 		print("Yenilmezlik kapalı. Can: ", GameManager.player_lives) ------------------------------------------------------------------------------------------------------------------------------------------ key.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends Area2D @export var door_id: String = "B" func _on_body_entered(body: Node2D) -> void: 	if body.is_in_group("Player"): 			GameManager.opened_doors.append(door_id) 			queue_free() ------------------------------------------------------------------------------------------------------------------------------------------ main_menu.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends Control @onready var main_buttons: VBoxContainer = $MainButtons @onready var options: Panel = $Options func _ready(): 	main_buttons.visible = true 	options.visible = false func _on_start_pressed() -> void: 	get_tree().change_scene_to_file("res://Scenes/game.tscn") func _on_options_2_pressed() -> void: 	main_buttons.visible = false 	options.visible = true func _on_exit_3_pressed() -> void: 	get_tree().quit() func _on_back_options_pressed() -> void: 	_ready() ------------------------------------------------------------------------------------------------------------------------------------------ slider.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends HSlider @export var audio_bus_name: String var audio_bus_id func _ready(): 	audio_bus_id = AudioServer.get_bus_index(audio_bus_name) func _on_value_changed(value: float) -> void: 	var db = linear_to_db(value) 	AudioServer.set_bus_volume_db(audio_bus_id, db) ------------------------------------------------------------------------------------------------------------------------------------------ opossum.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends CharacterBody2D const SPEED = 40.0 const JUMP_VELOCITY = -400.0 var direction := 1 var gravity = ProjectSettings.get_setting("physics/2d/default_gravity") var is_dead := false func _physics_process(delta): 	if is_dead: 		return 	if not is_on_floor(): 		velocity.y += gravity * delta 	velocity.x = direction * SPEED 	move_and_slide() 	$AnimatedSprite2D.flip_h = direction > 0 func die(): 	if is_dead: 		return 	is_dead = true 	 	$AnimatedSprite2D.play("death") 	if not $AnimatedSprite2D.animation_finished.is_connected(_on_death_animation_finished): 		$AnimatedSprite2D.animation_finished.connect(_on_death_animation_finished) 	set_physics_process(false) 	$CollisionShape2D.call_deferred("set_disabled", true) func _on_death_animation_finished(): 	queue_free() func _on_timer_timeout() -> void: 	if is_dead: 		return 	direction *= -1 func _on_area_2d_body_entered(body: Node2D) -> void: 	if is_dead: 		return 	if body.is_in_group("Player"): 		if "velocity" in body: 			body.velocity.y = -250 		die() func _on_area_2d_2_body_entered(body: Node2D) -> void: 	if is_dead: 		return 	if body.is_in_group("Player"): 		var vertical_diff = body.global_position.y - global_position.y 		if vertical_diff < -10: 			if "velocity" in body: 				body.velocity.y = -250 			die() 		else: 			 			if body.has_method("apply_knockback"): 				var knockback_direction = (body.global_position - global_position).normalized() 				body.apply_knockback(knockback_direction, 150.0, 0.16, true) 			print("Oyuncu canı: ", GameManager.player_lives) ------------------------------------------------------------------------------------------------------------------------------------------ player.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends CharacterBody2D const SPEED = 130.0 const JUMP_VELOCITY = -275.0 var knockback: Vector2 = Vector2.ZERO var knockback_timer: float = 0.0 var is_dying = false @onready var ladder_raycast = $RayCast2D @onready var death_timer: Timer = $Death_Timer @onready var hud = get_node("Camera2D/UI/HUD") func _ready(): 	death_timer.connect("timeout", Callable(self, "_on_DeathTimer_timeout")) func _physics_process(delta: float) -> void: 	if is_dying: 		return 	if knockback_timer > 0.0: 		velocity = knockback 		knockback_timer -= delta 		if knockback_timer <= 0.0: 			$AnimatedSprite2D.play("idle") 		move_and_slide() 		return 	var direction := Input.get_axis("ui_left", "ui_right") 	var on_ladder: bool = ladder_raycast and ladder_raycast.is_colliding() 	if on_ladder: 		var vertical := 0.0 		if Input.is_action_pressed("ui_up"): 			vertical = -SPEED 		elif Input.is_action_pressed("ui_down"): 			vertical = SPEED 		velocity = Vector2(direction * SPEED, vertical) 		if direction != 0: 			$AnimatedSprite2D.flip_h = direction < 0 		if vertical != 0 or direction != 0: 			$AnimatedSprite2D.play("climb") 		else: 			$AnimatedSprite2D.play("climb_idle") 		move_and_slide() 		return 	if not is_on_floor(): 		velocity += get_gravity() * delta 	if Input.is_action_just_pressed("ui_accept") and is_on_floor(): 		velocity.y = JUMP_VELOCITY 	if direction: 		velocity.x = direction * SPEED 		$AnimatedSprite2D.flip_h = direction < 0 	else: 		velocity.x = move_toward(velocity.x, 0, SPEED) 	if not is_on_floor(): 		if velocity.y < 0: 			$AnimatedSprite2D.play("jump") 		elif velocity.y > 0: 			$AnimatedSprite2D.play("fall") 	else: 		if direction: 			$AnimatedSprite2D.play("run") 		else: 			$AnimatedSprite2D.play("idle") 	move_and_slide() func apply_knockback(direction: Vector2, force: float, knockback_duration: float, play_animation := true) -> void: 	if is_dying or GameManager.invincibility: 		return 	GameManager.player_lives -= 1 	get_node("Camera2D/UI/HUD").update_hearts(GameManager.player_lives) 	if GameManager.player_lives <= 0: 		die() 		return 	if hud: 		hud.update_hearts(GameManager.player_lives) 	$Hurt.play() 	knockback = direction * force 	knockback_timer = knockback_duration 	if play_animation: 		$AnimatedSprite2D.play("hurt") func die(): 	if is_dying: 		return 	$Hurt.play() 	is_dying = true 	$AnimatedSprite2D.play("die") 	await move_player_up_and_down() 	if GameManager.player_lives <= 0: 		GameManager.reset_game_data() 	get_tree().reload_current_scene() func move_player_up_and_down(): 	var start_position = position 	var up_position = start_position + Vector2(0, -100) 	var down_position = start_position + Vector2(0, 100) 	while position.y > up_position.y: 		position.y -= 4 		await get_tree().create_timer(0.01).timeout 	while position.y < down_position.y: 		position.y += 4 		await get_tree().create_timer(0.01).timeout func _on_DeathTimer_timeout(): 	get_tree().reload_current_scene() ------------------------------------------------------------------------------------------------------------------------------------------ ui.gd ------------------------------------------------------------------------------------------------------------------------------------------ extends CanvasLayer func _ready(): 	GameManager.gained_gems.connect(update_gems_display) 	GameManager.gained_cherry.connect(update_cherry_display) 	 	update_gems_display(0) 	update_cherry_display(0) func update_gems_display(gained_gems: int) -> void: 	$GemsDisplay.text = str(GameManager.gems) 	 func update_cherry_display(gained_cherry: int) -> void: 	$CherryDisplay.text = str(GameManager.cherry) 


